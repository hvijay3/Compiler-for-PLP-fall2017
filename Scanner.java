/* *
 * Scanner for the class project in COP5556 Programming Language Principles 
 * at the University of Florida, Fall 2017.
 * 
 * This software is solely for the educational benefit of students 
 * enrolled in the course during the Fall 2017 semester.  
 * 
 * This software, and any software derived from it,  may not be shared with others or posted to public web sites,
 * either during the course or afterwards.
 * 
 *  @Beverly A. Sanders, 2017
  */

package cop5556fa17;


import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

public class Scanner {
	
	@SuppressWarnings("serial")
	public static class LexicalException extends Exception {
		
		int pos;

		public LexicalException(String message, int pos) {
			super(message);
			this.pos = pos;
		}
		
		public int getPos() { return pos; }

	}

	public static enum Kind {
		IDENTIFIER, INTEGER_LITERAL, BOOLEAN_LITERAL, STRING_LITERAL, 
		KW_x/* x */, KW_X/* X */, KW_y/* y */, KW_Y/* Y */, KW_r/* r */, KW_R/* R */, KW_a/* a */, 
		KW_A/* A */, KW_Z/* Z */, KW_DEF_X/* DEF_X */, KW_DEF_Y/* DEF_Y */, KW_SCREEN/* SCREEN */, 
		KW_cart_x/* cart_x */, KW_cart_y/* cart_y */, KW_polar_a/* polar_a */, KW_polar_r/* polar_r */, 
		KW_abs/* abs */, KW_sin/* sin */, KW_cos/* cos */, KW_atan/* atan */, KW_log/* log */, 
		KW_image/* image */,  KW_int/* int */, 
		KW_boolean/* boolean */, KW_url/* url */, KW_file/* file */, OP_ASSIGN/* = */, OP_GT/* > */, OP_LT/* < */, 
		OP_EXCL/* ! */, OP_Q/* ? */, OP_COLON/* : */, OP_EQ/* == */, OP_NEQ/* != */, OP_GE/* >= */, OP_LE/* <= */, 
		OP_AND/* & */, OP_OR/* | */, OP_PLUS/* + */, OP_MINUS/* - */, OP_TIMES/* * */, OP_DIV/* / */, OP_MOD/* % */, 
		OP_POWER/* ** */, OP_AT/* @ */, OP_RARROW/* -> */, OP_LARROW/* <- */, LPAREN/* ( */, RPAREN/* ) */, 
		LSQUARE/* [ */, RSQUARE/* ] */, SEMI/* ; */, COMMA/* , */, EOF;
	}



	/**
	 * Class to represent Tokens.
	 * 
	 * This is defined as a (non-static) inner class which means that each Token
	 * instance is associated with a specific Scanner instance. We use this when
	 * some token methods access the chars array in the associated Scanner.
	 * 
	 * 
	 * @author Beverly Sanders
	 *
	 */
	public class Token {
		public final Kind kind;
		public final int pos;
		public final int length;
		public final int line;
		public final int pos_in_line;

		public Token(Kind kind, int pos, int length, int line, int pos_in_line) {
			super();
			this.kind = kind;
			this.pos = pos;
			this.length = length;
			this.line = line;
			this.pos_in_line = pos_in_line;
		}

		public String getText() {
			if (kind == Kind.STRING_LITERAL) {
				return chars2String(chars, pos, length);
			} else
				return String.copyValueOf(chars, pos, length);
		}

		/**
		 * To get the text of a StringLiteral, we need to remove the enclosing "
		 * characters and convert escaped characters to the represented character. For
		 * example the two characters \ t in the char array should be converted to a
		 * single tab character in the returned String
		 * 
		 * @param chars
		 * @param pos
		 * @param length
		 * @return
		 */
		private String chars2String(char[] chars, int pos, int length) {
			StringBuilder sb = new StringBuilder();
			for (int i = pos + 1; i < pos + length - 1; ++i) {// omit initial and final "
				char ch = chars[i];
				if (ch == '\\') { // handle escape
					i++;
					ch = chars[i];
					switch (ch) {
					case 'b':
						sb.append('\b');
						break;
					case 't':
						sb.append('\t');
						break;
					case 'f':
						sb.append('\f');
						break;
					case 'r':
						sb.append('\r'); // for completeness, line termination chars not allowed in String literals
						break;
					case 'n':
						sb.append('\n'); // for completeness, line termination chars not allowed in String literals
						break;
					case '\"':
						sb.append('\"');
						break;
					case '\'':
						sb.append('\'');
						break;
					case '\\':
						sb.append('\\');
						break;
					default:
						assert false;
						break;
					}
				} else {
					sb.append(ch);
				}
			}
			return sb.toString();
		}

		/**
		 * precondition: This Token is an INTEGER_LITERAL
		 * 
		 * @returns the integer value represented by the token
		 */
		public int intVal() {
			assert kind == Kind.INTEGER_LITERAL;
			return Integer.valueOf(String.copyValueOf(chars, pos, length));
		}

		public String toString() {
			return "[" + kind + "," + String.copyValueOf(chars, pos, length) + "," + pos + "," + length + "," + line
					+ "," + pos_in_line + "]";
		}

		/**
		 * Since we overrode equals, we need to override hashCode.
		 * https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-
		 * 
		 * Both the equals and hashCode method were generated by eclipse
		 * 
		 */
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + ((kind == null) ? 0 : kind.hashCode());
			result = prime * result + length;
			result = prime * result + line;
			result = prime * result + pos;
			result = prime * result + pos_in_line;
			return result;
		}

		/**
		 * Override equals method to return true if other object is the same class and
		 * all fields are equal.
		 * 
		 * Overriding this creates an obligation to override hashCode.
		 * 
		 * Both hashCode and equals were generated by eclipse.
		 * 
		 */
		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			Token other = (Token) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (kind != other.kind)
				return false;
			if (length != other.length)
				return false;
			if (line != other.line)
				return false;
			if (pos != other.pos)
				return false;
			if (pos_in_line != other.pos_in_line)
				return false;
			return true;
		}

		/**
		 * used in equals to get the Scanner object this Token is associated with.
		 * 
		 * @return
		 */
		private Scanner getOuterType() {
			return Scanner.this;
		}

	}

	/**
	 * Extra character added to the end of the input characters to simplify the
	 * Scanner.
	 */
	static final char EOFchar = 0;

	/**
	 * The list of tokens created by the scan method.
	 */
	final ArrayList<Token> tokens;

	/**
	 * An array of characters representing the input. These are the characters from
	 * the input string plus and additional EOFchar at the end.
	 */
	final char[] chars;
	final HashMap<Character, Kind> oneSymbolOperatorMap = new HashMap<Character, Kind>();
	final HashMap<Character, Kind> twoSymbolOperatorMap = new HashMap<Character, Kind>();
	final HashMap<String, Kind> twoSymbolTokenMap = new HashMap<String, Kind>();
	final HashMap<Character, Kind> seperatorMap = new HashMap<Character, Kind>();
	final HashMap<String, Kind> keyWordMap = new HashMap<String, Kind>();
	final Set<Character> escapeSequenceSet = new HashSet<Character>();

	/**
	 * position of the next token to be returned by a call to nextToken
	 */
	private int nextTokenPos = 0;

	Scanner(String inputString) {
		int numChars = inputString.length();
		this.chars = Arrays.copyOf(inputString.toCharArray(), numChars + 1); // input string terminated with null char
		chars[numChars] = EOFchar;
		tokens = new ArrayList<Token>();
	}

	public static enum scan_state {
		START, IDENTIFIER, INT_LITERAL, COMMENT;
	}

	/**
	 * Method to scan the input and create a list of Tokens.
	 * 
	 * If an error is encountered during scanning, throw a LexicalException.
	 * 
	 * @return
	 * @throws LexicalException
	 */
	public Scanner scan() throws LexicalException {
		/* TODO Replace this with a correct and complete implementation!!! */
		oneSymbolOperatorMap.put('&', Kind.OP_AND);
		oneSymbolOperatorMap.put('?', Kind.OP_Q);
		oneSymbolOperatorMap.put(':', Kind.OP_COLON);
		oneSymbolOperatorMap.put('+', Kind.OP_PLUS);
		oneSymbolOperatorMap.put('/', Kind.OP_DIV);
		oneSymbolOperatorMap.put('@', Kind.OP_AT);
		oneSymbolOperatorMap.put('|', Kind.OP_OR);
		oneSymbolOperatorMap.put('%', Kind.OP_MOD);
		twoSymbolOperatorMap.put('=', Kind.OP_ASSIGN);
		twoSymbolOperatorMap.put('<', Kind.OP_LT);
		twoSymbolOperatorMap.put('>', Kind.OP_GT);
		twoSymbolOperatorMap.put('-', Kind.OP_MINUS);
		twoSymbolOperatorMap.put('!', Kind.OP_EXCL);
		twoSymbolOperatorMap.put('*', Kind.OP_TIMES);
		twoSymbolTokenMap.put(">=", Kind.OP_GE);
		twoSymbolTokenMap.put("<=", Kind.OP_LE);
		twoSymbolTokenMap.put("<-", Kind.OP_LARROW);
		twoSymbolTokenMap.put("->", Kind.OP_RARROW);
		twoSymbolTokenMap.put("**", Kind.OP_POWER);
		twoSymbolTokenMap.put("!=", Kind.OP_NEQ);
		twoSymbolTokenMap.put("==", Kind.OP_EQ);
		keyWordMap.put("abs", Kind.KW_abs);
		keyWordMap.put("atan", Kind.KW_atan);
		keyWordMap.put("boolean", Kind.KW_boolean);
		keyWordMap.put("cart_x", Kind.KW_cart_x);
		keyWordMap.put("cart_y", Kind.KW_cart_y);
		keyWordMap.put("cos", Kind.KW_cos);
		keyWordMap.put("DEF_X", Kind.KW_DEF_X);
		keyWordMap.put("DEF_Y", Kind.KW_DEF_Y);
		keyWordMap.put("file", Kind.KW_file);
		keyWordMap.put("image", Kind.KW_image);
		keyWordMap.put("int", Kind.KW_int);
		keyWordMap.put("log", Kind.KW_log);
		keyWordMap.put("polar_a", Kind.KW_polar_a);
		keyWordMap.put("polar_r", Kind.KW_polar_r);
		keyWordMap.put("r", Kind.KW_r);
		keyWordMap.put("R", Kind.KW_R);
		keyWordMap.put("SCREEN", Kind.KW_SCREEN);
		keyWordMap.put("sin", Kind.KW_sin);
		keyWordMap.put("url", Kind.KW_url);
		keyWordMap.put("x", Kind.KW_x);
		keyWordMap.put("a", Kind.KW_a);
		keyWordMap.put("A", Kind.KW_A);
		keyWordMap.put("X", Kind.KW_X);
		keyWordMap.put("Y", Kind.KW_Y);
		keyWordMap.put("y", Kind.KW_y);
		keyWordMap.put("Z", Kind.KW_Z);
		seperatorMap.put('[', Kind.LSQUARE);
		seperatorMap.put(']', Kind.RSQUARE);
		seperatorMap.put('(', Kind.LPAREN);
		seperatorMap.put(')', Kind.RPAREN);
		seperatorMap.put(';', Kind.SEMI);
		seperatorMap.put(',', Kind.COMMA);
		escapeSequenceSet.add('t');
		escapeSequenceSet.add('b');
		escapeSequenceSet.add('f');
		escapeSequenceSet.add('r');
		escapeSequenceSet.add('"');
		escapeSequenceSet.add('n');
		escapeSequenceSet.add('\'');
		escapeSequenceSet.add('\\');


		int pos = 0;
		int line = 1;
		int posInLine = 1;
		int startPos = pos;
		int charsLength = chars.length - 1;
		Scanner.scan_state state = scan_state.START;
		int accumLength = 0;
		int prevLineLength = 0;

		while (pos < charsLength) {

			switch (state)

			{

			case START:

				char c = chars[pos];
				
				if (Character.isDigit(c) && c != '0') {

					state = scan_state.INT_LITERAL;

				} else if (isJavaIdentifierStartChar(c)) {

					state = scan_state.IDENTIFIER;

				}

				else if (oneSymbolOperatorMap.containsKey(c)) {
					if (chars[pos] != '/') {
						tokens.add(new Token(oneSymbolOperatorMap.get(c), startPos, 1, line, posInLine));
						pos++;
						startPos = pos;
						posInLine = startPos - accumLength + 1;
					} else if (pos == charsLength - 1 || (pos < charsLength - 1 && chars[pos + 1] != '/')) {
						tokens.add(new Token(oneSymbolOperatorMap.get('/'), startPos, 1, line, posInLine));
						pos++;
						startPos = pos;
						posInLine = startPos - accumLength + 1;
					} else {
						state = scan_state.COMMENT;
					}
				}

				else if (twoSymbolOperatorMap.containsKey(c)) {

					if (pos < charsLength - 1 && twoSymbolTokenMap.containsKey(new String(chars, pos, 2))) {
						tokens.add(new Token(twoSymbolTokenMap.get(new String(chars, pos, 2)), startPos, 2, line,
								posInLine));
						pos = pos + 2;
						startPos = pos;
						posInLine = startPos - accumLength + 1;
					} else {
						tokens.add(new Token(twoSymbolOperatorMap.get(c), startPos, 1, line, posInLine));
						pos = pos + 1;
						startPos = pos;
						posInLine = startPos - accumLength + 1;
					}
				}

				else if (isWhitespaceChar(c) && !isSingleSymbolLineTerminator(c, pos)) {
					pos++;
					startPos = pos;
					posInLine = startPos - accumLength + 1;

				} else if (c == '0') {

					tokens.add(new Token(Kind.INTEGER_LITERAL, startPos, 1, line, posInLine));
					pos = pos + 1;
					startPos = pos;
					posInLine = startPos - accumLength + 1;
				}

				else if (isSingleSymbolLineTerminator(c, pos)) {
					if (c == '\r' && pos < chars.length - 2 && chars[pos + 1] == '\n') {
						pos++;
					}
					pos++;
					startPos = pos;
					if (line == 1) {
						prevLineLength = startPos;
					} else {
						prevLineLength = startPos - accumLength;
					}
					accumLength = accumLength + prevLineLength;
					posInLine = startPos - accumLength + 1;
					line++;

				} else if (seperatorMap.containsKey(c)) {

					tokens.add(new Token(seperatorMap.get(c), startPos, 1, line, posInLine));
					pos++;
					startPos = pos;
					posInLine = startPos - accumLength + 1;

				}
				
				else if (c == '"') {
					pos++;
					while (chars[pos] != '"') {

						if (chars[pos] == EOFchar) {

							throw new LexicalException("Exception due to \" not found ", pos);

						}

						if (isStringCharacter(chars[pos], pos)) {
							
							if ((chars[pos]=='\\' && pos <charsLength-1)) {
								
							if(escapeSequenceSet.contains(chars[pos+1])) {
								pos++;
							}
							else
							{	
								throw new LexicalException("Unidentified character \\"
										+ " in string literal at position :" + pos, pos+1);
							}}
							pos++;
							
						}
						else
						{
							throw new LexicalException("Unidentified character \" | escape sequence with one \\"
									+ " in string literal at position " + pos, pos);
						}

					}
					tokens.add(new Token(Kind.STRING_LITERAL, startPos, (pos - startPos + 1), line, posInLine));
					pos++;
					startPos = pos;
					posInLine = startPos - accumLength + 1;
					// error handling
				}
				else
				{
					throw new LexicalException("Unidentified character at position " + pos, pos);
				}

				break;

			case IDENTIFIER:
				pos++;
				while ( pos < charsLength && 
						(isJavaIdentifierStartChar(chars[pos]) || Character.isDigit(chars[pos]))) {
					
					pos++;
				}
				String str = new String(chars, startPos, pos - startPos);
				Kind k1;
				if (keyWordMap.containsKey(str)) {
					k1 = keyWordMap.get(str);

				} else if (str.equals("true") || str.equals("false")) {
					k1 = Kind.BOOLEAN_LITERAL;
				} else {
					k1 = Kind.IDENTIFIER;
				}

				tokens.add(new Token(k1, startPos, pos - startPos, line, posInLine));
				startPos = pos;
				posInLine = startPos - accumLength + 1;
				state = scan_state.START;
				break;

			case INT_LITERAL:
				pos++;
				while (pos < charsLength && Character.isDigit(chars[pos])) {
					pos++;
				}
				try {
					int x = Integer.parseInt(new String(chars,startPos,pos-startPos));
				}
				catch(NumberFormatException e)
				{
					throw new LexicalException("Exception due to integar literal value out of bound", pos);
				}
				tokens.add(new Token(Kind.INTEGER_LITERAL, startPos, pos - startPos, line, posInLine));
				startPos = pos;
				posInLine = startPos - accumLength+1;
				state = scan_state.START;
				break;
			case COMMENT:
				if (pos < charsLength - 1 && new String(chars, pos, 2).equals("//")) {
					pos = pos + 2;
					while ( pos < charsLength && chars[pos] >= 0 && chars[pos] <=255 &&
							!isSingleSymbolLineTerminator(chars[pos], pos)) {
						pos++;
						
					}
				}
				startPos = pos;
				posInLine = startPos - accumLength + 1;
				state = scan_state.START;
				
				break;
				default:
					throw new LexicalException("Unidentified character at line " + line + 
							"and at position " +pos , pos);

			}

		}
		tokens.add(new Token(Kind.EOF, pos, 0, line, posInLine));
		return this;
	}

	private boolean isWhitespaceChar(char c) {
		// TODO Auto-generated method stub
		if(c=='\t' || c=='\f' || c==' ' || isSingleSymbolLineTerminator(c,0))
		{
			return true;
		}
		else
		{
		return false;
	}}

	private boolean isJavaIdentifierStartChar(char c) {
		// TODO Auto-generated method stub
		if((c>='a' && c<='z') || (c>='A' && c<='Z') || 
				 ( c=='$' || c=='_'))
		{
			return true;
		}
		return false;
	}

	private boolean isStringCharacter(char c, int pos) {
		// TODO Auto-generated method stub
		if ((c != '"'  && !isSingleSymbolLineTerminator(c, pos) && chars[pos] >= 0 && chars[pos] <=255 )) {
			return true;
		}
		return false;
	}

	private boolean isSingleSymbolLineTerminator(char c, int pos) {
		// TODO Auto-generated method stub
		if (c == '\n') {
			return true;
		} else if (c == '\r') {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Returns true if the internal interator has more Tokens
	 * 
	 * @return
	 */
	public boolean hasTokens() {
		return nextTokenPos < tokens.size();
	}

	/**
	 * Returns the next Token and updates the internal iterator so that the next
	 * call to nextToken will return the next token in the list.
	 * 
	 * It is the callers responsibility to ensure that there is another Token.
	 * 
	 * Precondition: hasTokens()
	 * 
	 * @return
	 */
	public Token nextToken() {
		return tokens.get(nextTokenPos++);
	}

	/**
	 * Returns the next Token, but does not update the internal iterator. This means
	 * that the next call to nextToken or peek will return the same Token as
	 * returned by this methods.
	 * 
	 * It is the callers responsibility to ensure that there is another Token.
	 * 
	 * Precondition: hasTokens()
	 * 
	 * @return next Token.
	 */
	public Token peek() {
		return tokens.get(nextTokenPos);
	}

	/**
	 * Resets the internal iterator so that the next call to peek or nextToken will
	 * return the first Token.
	 */
	public void reset() {
		nextTokenPos = 0;
	}

	/**
	 * Returns a String representation of the list of Tokens
	 */
	public String toString() {
		StringBuffer sb = new StringBuffer();
		sb.append("Tokens:\n");
		for (int i = 0; i < tokens.size(); i++) {
			sb.append(tokens.get(i)).append('\n');
		}
		return sb.toString();
	}

}
